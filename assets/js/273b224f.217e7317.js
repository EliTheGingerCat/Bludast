"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2503],{31110:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"","params":[{"name":"buffer","desc":"","lua_type":"string"},{"name":"bufferSize","desc":"","lua_type":"number"},{"name":"names","desc":"","lua_type":"AstNameTable"}],"returns":[{"desc":"","lua_type":"Lexer"}],"function_type":"static","source":{"line":173,"path":"src/Ast/Lexer.luau"}},{"name":"current","desc":"","params":[],"returns":[{"desc":"","lua_type":"Lexeme"}],"function_type":"method","source":{"line":261,"path":"src/Ast/Lexer.luau"}},{"name":"fixupMultilineString","desc":"Lua rules for multiline strings are as follows:\\n- standalone \\\\r, \\\\r\\\\n, \\\\n\\\\r and \\\\n are all considered newlines\\n- first newline in the multiline string is skipped\\n- all other newlines are normalized to \\\\n\\n\\nSince our lexer just treats \\\\n as newlines, we apply a simplified set of rules that is sufficient to get normalized newlines for Windows/Unix:\\n- \\\\r\\\\n and \\\\n are considered newlines\\n- first newline is skipped\\n- newlines are normalized to \\\\n\\n\\nThis makes the string parsing behavior consistent with general lexing behavior - a standalone \\\\r isn\'t considered a new line from the line tracking perspective.","params":[{"name":"data","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"string"}],"function_type":"static","source":{"line":967,"path":"src/Ast/Lexer.luau"}}],"properties":[{"name":"buffer","desc":"","lua_type":"string","since":"v0.1.0","private":true,"readonly":true,"source":{"line":100,"path":"src/Ast/Lexer.luau"}},{"name":"bufferSize","desc":"","lua_type":"number","since":"v0.1.0","private":true,"readonly":true,"source":{"line":107,"path":"src/Ast/Lexer.luau"}},{"name":"offset","desc":"","lua_type":"number","since":"v0.1.0","private":true,"source":{"line":113,"path":"src/Ast/Lexer.luau"}},{"name":"line","desc":"","lua_type":"number","since":"v0.1.0","private":true,"source":{"line":119,"path":"src/Ast/Lexer.luau"}},{"name":"lineOffset","desc":"","lua_type":"number","since":"v0.1.0","private":true,"source":{"line":125,"path":"src/Ast/Lexer.luau"}},{"name":"lexeme","desc":"","lua_type":"Lexeme","since":"v0.1.0","private":true,"source":{"line":131,"path":"src/Ast/Lexer.luau"}},{"name":"names","desc":"","lua_type":"AstNameTable","since":"v0.1.0","private":true,"readonly":true,"source":{"line":138,"path":"src/Ast/Lexer.luau"}},{"name":"skipComments","desc":"","lua_type":"boolean","since":"v0.1.0","private":true,"source":{"line":144,"path":"src/Ast/Lexer.luau"}},{"name":"readNames","desc":"","lua_type":"boolean","since":"v0.1.0","private":true,"source":{"line":150,"path":"src/Ast/Lexer.luau"}},{"name":"prevLocation","desc":"","lua_type":"Location","since":"v0.1.0","private":true,"source":{"line":156,"path":"src/Ast/Lexer.luau"}},{"name":"braceStack","desc":"","lua_type":"{number}","since":"v0.1.0","private":true,"readonly":true,"source":{"line":163,"path":"src/Ast/Lexer.luau"}}],"types":[],"name":"Lexer","desc":"Class from `root/Ast/src/Lexer.cpp`.  \\nScans Luau code and converts them to [Lexemes](Lexeme), splitting the code up into more meaningful chunks.","source":{"line":75,"path":"src/Ast/Lexer.luau"}}')}}]);